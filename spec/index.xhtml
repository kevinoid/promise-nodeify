<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>promiseNodeify</h1>
      <dl>
        <section class="suite">
          <h1>when called with a function</h1>
          <dl>
            <dt>passes (null, value) to callback on resolution</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
promiseNodeify(promise, function(err, result) {
  assert.strictEqual(arguments.length, 2);
  assert.strictEqual(err, null);
  assert.strictEqual(result, value);
  done();
});</code></pre></dd>
            <dt>passes undefined value to callback on resolution</dt>
            <dd><pre><code>let value;
const promise = PPromise.resolve(value);
promiseNodeify(promise, (err, result) =&#x3E; {
  // Note:  arguments.length is unspecified
  // Although it is currently 2, that may change.  Don&#x27;t depend on it.
  assert.strictEqual(err, null);
  assert.strictEqual(result, value);
  done();
});</code></pre></dd>
            <dt>passes Error cause to callback on rejection</dt>
            <dd><pre><code>const cause = new Error();
const promise = PPromise.reject(cause);
promiseNodeify(promise, function(err) {
  assert.strictEqual(arguments.length, 1);
  assert.strictEqual(err, cause);
  done();
});</code></pre></dd>
            <dt>passes truthy cause to callback on rejection</dt>
            <dd><pre><code>const cause = true;
const promise = PPromise.reject(cause);
promiseNodeify(promise, function(err) {
  assert.strictEqual(arguments.length, 1);
  assert.strictEqual(err, cause);
  done();
});</code></pre></dd>
            <dt>passes Error with falsey .cause on rejection</dt>
            <dd><pre><code>const cause = 0;
const promise = PPromise.reject(cause);
promiseNodeify(promise, function(err) {
  assert.strictEqual(arguments.length, 1);
  assert(err instanceof Error);
  assert.strictEqual(err.message, String(cause));
  assert(hasOwnProperty.call(err, &#x27;cause&#x27;));
  assert.strictEqual(err.cause, cause);
  done();
});</code></pre></dd>
            <dt>returns undefined</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
const retVal = promiseNodeify(promise, () =&#x3E; {});
assert.strictEqual(retVal, undefined);</code></pre></dd>
            <dt>ignores callback return value</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
promiseNodeify(promise, () =&#x3E; true);
return promise.then((result) =&#x3E; {
  assert.strictEqual(result, value);
});</code></pre></dd>
            <dt>callback exception causes uncaughtException</dt>
            <dd><pre><code>const value = {};
const errCallback = new Error(&#x27;Test callback error&#x27;);
const promise = PPromise.resolve(value);
let unhandledRejection;
function onUnhandledRejection(reason) {
  unhandledRejection = reason;
}
process.once(&#x27;unhandledRejection&#x27;, onUnhandledRejection);
promiseNodeify(promise, () =&#x3E; { throw errCallback; });
return promiseFinally(
  awaitGlobalException((err) =&#x3E; {
    assert.strictEqual(err, errCallback);
  }),
  () =&#x3E; {
    process.removeListener(&#x27;unhandledRejection&#x27;, onUnhandledRejection);
    return unhandledRejection &#x26;&#x26; PPromise.reject(unhandledRejection);
  }
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>when called with a non-function</h1>
          <dl>
            <dt>returns a Promise which resolves with the same value</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
const promise2 = promiseNodeify(promise, null);
return promise2.then((result) =&#x3E; {
  assert.strictEqual(result, value);
});</code></pre></dd>
            <dt>returns a Promise which rejects with the same cause</dt>
            <dd><pre><code>const cause = new Error();
const promise = PPromise.reject(cause);
const promise2 = promiseNodeify(promise, null);
return promise2.then(
  () =&#x3E; {
    assert(false, &#x27;Promise should be rejected&#x27;);
  },
  (err) =&#x3E; {
    assert.strictEqual(err, cause);
  }
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.delegated</h1>
          <dl>
            <dt>forwards to .nodeify method on promise</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
const nodeifyArg = {};
const nodeifyRetVal = {};
promise.nodeify = function(arg) {
  assert.strictEqual(arg, nodeifyArg);
  return nodeifyRetVal;
};
const retVal = promiseNodeify.delegated(promise, nodeifyArg);
assert.strictEqual(retVal, nodeifyRetVal);</code></pre></dd>
            <dt>forwards to inherited .nodeify method on promise</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
const nodeifyArg = {};
const nodeifyRetVal = {};
promise.nodeify = function(arg) {
  assert.strictEqual(arg, nodeifyArg);
  return nodeifyRetVal;
};
const promise2 = Object.create(promise);
const retVal = promiseNodeify.delegated(promise2, nodeifyArg);
assert.strictEqual(retVal, nodeifyRetVal);</code></pre></dd>
            <dt>ignores non-function .nodeify on promise</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
promise.nodeify = true;
promiseNodeify.delegated(promise, function(err, result) {
  assert.strictEqual(arguments.length, 2);
  assert.strictEqual(err, null);
  assert.strictEqual(result, value);
  done();
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.nodeifyThis</h1>
          <dl>
            <dt>can be used as a method on a promise</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
promise.nodeify = promiseNodeify.nodeifyThis;
promise.nodeify(function(err, result) {
  assert.strictEqual(arguments.length, 2);
  assert.strictEqual(err, null);
  assert.strictEqual(result, value);
  done();
});</code></pre></dd>
            <dt>when given a function, returns undefined</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
promise.nodeify = promiseNodeify.nodeifyThis;
const retVal = promise.nodeify(() =&#x3E; {});
assert.strictEqual(retVal, undefined);</code></pre></dd>
            <dt>when not given a function, returns a Promise</dt>
            <dd><pre><code>const value = {};
const promise = PPromise.resolve(value);
promise.nodeify = promiseNodeify.nodeifyThis;
const promise2 = promise.nodeify(null);
return promise2.then((result) =&#x3E; {
  assert.strictEqual(result, value);
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
